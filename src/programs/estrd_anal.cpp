//---------------------------------------------------------------------
// Analyze an estrd (range and doppler centroid offset)file generated by
// the sar_processor
// Prints out best time shift and altitude error at periapsis to account
// for the shifts followed by columns of data
//  Time SAB range doppler drang(medfilt) ddop(medfilt) drang(bestephem) ddop(bestephem)
//  anglerror surfaceheight ddop(surfaceheight) drang(bestephem,bestatt) ddop(bestephem,bestatt)
//
// Time:= time from closest approach (s)
// SAB = sab_counter
// range = nominal range to boresight
// doppler = nominal boresight doppler
// drang(medfilt) = range offset from estrd file median filtered (km)
// ddop(medfilt) = doppler offset from estrd file median filtered (Hz)
// drang(bestephem)= residual range offset for minimum MSE altitude and timing
//                   error (km) Currently altitude error is assumed to be zero
// ddop(bestephem)= residual doppler offset for minimum MSE altitude and timing
//                   error (hz) Currently altitude error is assumed to be zero
// angleerror     = if we assume perfect sphere of nominal size and perfect
//                  ephemeris, this is the angle between the nominal boresight
//                  and the boresight derived from the range and doppler 
//                  offsets (millirads)
// surfaceheight = actual surface height at boesight given drange and
//                  perfect attitude and ephemeris
// 
// ddop(surfaceheight) = estimate of doppler offset given the surface height
//                       and the corresponding new boresight location for that
//                       surface height (it is only directly above the nominal
//                       boresight for the 0 incidence angle case
//
// drang(bestephem,bestatt)= residual range offset for minimum MSE timing
//                   error in ephemeris and attitude (2 independent timing errors are
//                   computed) (km)
// ddop(bestephem,bestatt)= residual doppler offset for minimum MSE timing
//                   error in ephemeris and attitude (2 independent timing errors are
//                   computed) (Hz)
//--------------------------------------------------------- 

#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <getopt.h>
#include "Array.h"
#include "Plot.h"
#include "Config.h"
#include "Io.h"
#include "Units.h"
#include "Error.h"
#include "RadiometerData.h"
#include "Frame.h"
#include "Time.h"
#include "TargetGeom.h"
#include "config_keywords.h"
#include "Constants.h"
#include "TemplateUtils.h"
#include "CassiniSim.h"
#include "Flyby.h"

using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::terminate;
void myUnexpected() throw()
  {
  cout << "Unexpected exception" << endl;
  terminate();
  }

#define MAX_ESTRD_LINES 10000


double median(double* x, int n){
  double* y=(double*)malloc(sizeof(double)*n);
  for(int i=0;i<n;i++){
    y[i]=x[i];
  }
  int idx = 0;
    while (idx < n - 1)
    {
      if (y[idx] <= y[idx+1])
        {
	  idx++;
        }
      else
        {
	  float tmp = y[idx+1];
          y[idx+1] = y[idx];
          y[idx] = tmp;
          idx = 0;
        }
    }

    return(y[n/2]);
}

int main(int argc, char* argv[])

{

 std::set_unexpected(myUnexpected);
 double range[MAX_ESTRD_LINES];
 double dop[MAX_ESTRD_LINES];
 double t[MAX_ESTRD_LINES];
 double dr[MAX_ESTRD_LINES];
 double drmed[MAX_ESTRD_LINES];
 double dd[MAX_ESTRD_LINES];
 double ddmed[MAX_ESTRD_LINES];
 int  sabc[MAX_ESTRD_LINES];
 double drbe[MAX_ESTRD_LINES];
 double ddbe[MAX_ESTRD_LINES];
 double ang[MAX_ESTRD_LINES];
 double ht[MAX_ESTRD_LINES];
 double ddht[MAX_ESTRD_LINES];
 double dr2t[MAX_ESTRD_LINES];
 double dd2t[MAX_ESTRD_LINES];
 double fshiftdop[MAX_ESTRD_LINES];
 double fshiftrange[MAX_ESTRD_LINES];

try
  {
    // Parse command line
    if(argc!=5 && argc!=11){
      cerr<<"Usage: " << argv[0] <<" estrdfile cfgfile median_filter_size outfile [min max  fshift in MHz] [min max attitude tshift in s] [min max ephemeris tshiftin s] \n" << endl;
      exit(1);
    }

    int clidx=1;
    string estrdfile=argv[clidx++];
    string cfgfile=argv[clidx++];
    int mfsize=atoi(argv[clidx++]);
    if(mfsize%2==0){
      cerr << "Error mfsize must be an odd integer" << endl;
      exit(2);
    }
    string outfile=argv[clidx++]; 
    int skipsearch=0;
    double best_time_err=0, bestfshdf=0, bestfshdt=0;
    double fstart=-20e6, fend=0, tstart=-1,tend=1,dt1=-1,dt2=1;
    if(argc>5){
      fstart=atof(argv[clidx++])*1000000;
      fend=atof(argv[clidx++])*1000000;
      tstart=atof(argv[clidx++]);
      tend=atof(argv[clidx++]);
      dt1=atof(argv[clidx++]);
      dt2=atof(argv[clidx++]);

    }


    // Configure SPICE stuff
    set_unit_option("none");

    //--------------------------------------------------------
    // Load configuration parameters 
    //--------------------------------------------------------
    
    Config cfg(argv[0],cfgfile);
    
    string target = cfg.str("target");

    //-------------------------
    // Load spice kernel files.
    //-------------------------

    cout << "Loading spice files" << endl;
    Frame::config(cfg);

    // Config flyby
    Flyby flyby(cfg);
    
    //----------------
    //beam3 and its frame
    //-----------------
    Frame bf= Frame("CASSINI_RADAR_3","Cassini");
    Beam beam3(3,cfg);


    //--------------------
    // Target frame
    //--------------------
    Frame tf = Frame("IAU_TITAN","Titan");

    //---------------------------
    // Setup spacecraft support
    //---------------------------

    cout << "Setting up spacecraft simulation" << endl;
    CassiniSim sc(cfg);

    //-------------------------- read in ESTRD file
    int N=0;
    FileMgr efm(estrdfile,"r");
    while(!efm.eof()){
      string str;
      str=efm.parseNextString();
      t[N]=strtod(str.c_str(),NULL);
      str=efm.parseNextString();
      sabc[N]=atoi(str.c_str());
      str=efm.parseNextString();
      str=efm.parseNextString();
      str=efm.parseNextString();
      str=efm.parseNextString();
      dr[N]=strtod(str.c_str(),NULL);
      str=efm.parseNextString();
      dd[N]=strtod(str.c_str(),NULL);
      N++;
    }  
    efm.close();

    // median filter parameters
    int mrad=mfsize/2;
    for(int i=0;i<N;i++){
      if(i<mrad){
	ddmed[i]=median(&(dd[0]),2*i+1);
	drmed[i]=median(&(dr[0]),2*i+1);
      }
      else if(i>N-mrad-1){
	int rad=N-i-1;
	ddmed[i]=median(&(dd[N-2*rad-1]),2*rad+1);
	drmed[i]=median(&(dr[N-2*rad-1]),2*rad+1);
      }
      else{
	ddmed[i]=median(&(dd[i-mrad]),mfsize);
	drmed[i]=median(&(dr[i-mrad]),mfsize);	
      }
    }    

    // compute time and at periapsis and other constants
    Time tepoch=flyby.epochTime();
    double tperi=tepoch.et().getInUnits("s");
    Uvar carrfreq(13.78e9,"Hz");
    Uvar lambda=speed_light/carrfreq;


    // est nominal doppler and range  and angle error
    for(int i=0;i<N;i++){
      try{
	Time time;
	double tdoub=tperi+t[i];
	time.setEt(tdoub);
	DirectionVector b3bore_old(bf,tdoub,0,0,1);
	TargetGeom tg(time);
	tg.setTarget();
	b3bore_old.representIn(tf);
	StateVector sc_state;
	tf.ephemeris(sc_state,"Cassini",time,"NONE");
	tg.setState(sc_state);
	tg.setLookDirection(b3bore_old);
	
	Uvar rangeuv=tg.range();
	Uvar doppleruv=tg.doppler(lambda);
	range[i]=rangeuv.getInUnits("km");
	dop[i]=doppleruv.getInUnits("Hz");
	// compute new beam 3 boresight
	TargetGeom tg2(time);
	tg2.setTarget();
	tg2.setState(sc_state);
	Uvar drange(drmed[i],"km"),ddopc(ddmed[i],"Hz");
	tg2.setRangeDopplerInTargetFrame(rangeuv+drange,doppleruv+ddopc,lambda);
	DirectionVector b3bore_new;
	b3bore_new=tg2.lookDirection();
	Uvar anguv=b3bore_old.angle(b3bore_new);
	ang[i]=anguv.getInUnits("rad")*1000;
      }
      catch(ErrorMessage e){
	ang[i]=2*pi*1000;
	range[i]=0;
	dop[i]=0;
      }
    }

    // est minimum MSE ephemeris (Kepplerian with altitude error at periapsis and time offset)
    // AND compute residual doppler and range errors
    double minmse=100000000000.0;
    // This part is incomplete because altitude error is not yet implemented
    
    double dttol=(dt2-dt1)/4;
    dt2+=dttol/10.0;
    if(skipsearch<2){
    if(dttol<0.001) dttol=0.0015;
    while(dttol>0.001){
      for(float dt=dt1;dt<=dt2;dt+=dttol){
	int num=0;
	double mse=0;
        double rmean=0;
	for(int i=0;i<N;i++){
	  double r1=0,d1=0;
	  try{
	    Time time;
	    double tdoub=tperi+t[i]+dt;
	    time.setEt(tdoub);
	    DirectionVector b3bore_old(bf,tdoub,0,0,1);
	    TargetGeom tg(time);
	    tg.setTarget();
	    b3bore_old.representIn(tf);
	    StateVector sc_state;
	    tf.ephemeris(sc_state,"Cassini",time,"NONE");
	    tg.setState(sc_state);
	    tg.setLookDirection(b3bore_old);
	    
	    Uvar rangeuv=tg.range();
	    Uvar doppleruv=tg.doppler(lambda);
	    r1=rangeuv.getInUnits("km");
	    d1=doppleruv.getInUnits("Hz");
	  }
	  catch(ErrorMessage e){
	    r1=0;
	    d1=0;
	  }
	  if(r1!=0 && range[i]!=0){
	    num++;
	    float rangeerr=r1-(range[i]+drmed[i]);
	    mse+=rangeerr*rangeerr;
            rmean+=rangeerr;
	  }
	}
      rmean=rmean/num;
      //mse=mse-num*rmean*rmean;
      mse/=num-1;
      if(minmse>mse){
	minmse=mse;
	best_time_err=dt;
      }
      printf("dt=%g RMS=%g\n",dt,sqrt(mse));
      fflush(stdout);
      } // end dt loop
      dttol=dttol/2;
      dt1=best_time_err-2*dttol;
      dt2=best_time_err+2.5*dttol;

    } // end while
    } // end skipsearch case

   
    
    for(int i=0;i<N;i++){
      double r1=0,d1=0;
      try{
	Time time;
	double tdoub=tperi+t[i]+best_time_err;
	time.setEt(tdoub);
	DirectionVector b3bore_old(bf,tdoub,0,0,1);
	TargetGeom tg(time);
	tg.setTarget();
	b3bore_old.representIn(tf);
	StateVector sc_state;
	tf.ephemeris(sc_state,"Cassini",time,"NONE");
	tg.setState(sc_state);
	tg.setLookDirection(b3bore_old);
	
	Uvar rangeuv=tg.range();
	Uvar doppleruv=tg.doppler(lambda);
	r1=rangeuv.getInUnits("km");
	d1=doppleruv.getInUnits("Hz");
      }
      catch(ErrorMessage e){
	r1=0;
	d1=0;
      }
      if(r1==0 || range[i]==0){
	drbe[i]=2575;
	ddbe[i]=1000000;
      }
      else{
	drbe[i]=range[i]+drmed[i]-r1;
	ddbe[i]=dop[i]+ddmed[i]-d1;
      }
    }
   
    // est surface height and residual doppler error
    for(int i=0;i<N;i++){
      try{
	Time time;
	double tdoub=tperi+t[i];
	time.setEt(tdoub);
	DirectionVector b3bore_old(bf,tdoub,0,0,1);
	TargetGeom tg(time);
	tg.setTarget();
	b3bore_old.representIn(tf);
	StateVector sc_state;
	tf.ephemeris(sc_state,"Cassini",time,"NONE");
	tg.setState(sc_state);
	tg.setLookDirection(b3bore_old);

	Uvar inc=tg.incidenceAngle();
	ht[i]=-cos(inc)*drmed[i];
	ddht[i]=0; // Incomplete
      }
      catch(ErrorMessage e){
	ht[i]=2575.0;
	ddht[i]=400000;
      }
    }
  
    // est residual doppler error given a 10Mhz frequency shift in the carrier
    
    double minfsherr=1e99;
    Uvar duv,ruv;
    Frame j2000("J2000","Cassini");	
    double ttol=(tend-tstart)/4;
    tend+=ttol/10.0;
    double ftol=(fend-fstart)/4;
    fend+=ftol/10.0;
    if(skipsearch<1){
    if(ttol<0.001) ttol=0.0015;
    if(ftol<0.001) ftol=0.0015;
    while(ttol>0.001 || ftol>10000){	  
    for( float dt=tstart;dt<tend;dt+=ttol){
     for( float df=fstart;df<fend;df+=ftol){
	float err=0, dstd=0, rstd=0, dmean=0;
	float derr,rerr;

	for(int i=0;i<N;i++){
	  try{
	    Time time_eph, time_att;
	    double teph=tperi+t[i]+best_time_err;
	    double tatt=tperi+t[i]+dt;
	    time_eph.setEt(teph);
	    time_att.setEt(tatt);
	    DirectionVector b3bore_old(bf,tatt,0,0,1);
	    TargetGeom tg(time_eph);
	    tg.setTarget();
	    b3bore_old.representIn(j2000);
            b3bore_old.setTime(time_eph);
            b3bore_old.representIn(tf);
	    StateVector sc_state;
	    tf.ephemeris(sc_state,"Cassini",time_eph,"NONE");
	    tg.setState(sc_state);
	    tg.setLookDirection(b3bore_old);
	    Uvar lambda2=speed_light/(carrfreq+Uvar(df,"Hz"));
	    duv=tg.doppler(lambda2);
	    ruv=tg.range();
	    derr=dop[i]+ddmed[i]-duv.getInUnits("Hz");
	    rerr=range[i]+drmed[i]-ruv.getInUnits("Hz");
     	    if(fabs(derr)>10000){
	      derr=0;
	      rerr=0;
	    }
	  }
	  catch(ErrorMessage e){
	    derr=0;
	    rerr=0;
	  }
	  err+=derr*derr +rerr*rerr*1000000;
	  rstd+=rerr*rerr;
	  dstd+=derr*derr;
	  dmean+=derr;
	}
	err=sqrt(err/N);
	rstd=sqrt(rstd/N);
        dmean=dmean/N;
        //dstd=dstd-N*dmean*dmean;
	dstd=sqrt(dstd/(N-1));
	if(dstd<minfsherr){
	  minfsherr=dstd;
	  bestfshdt=dt;
	  bestfshdf=df;
	}

	printf("bestephdt=%g dt=%g df =%g  err=%g derr=%g rerr=%g\n",best_time_err,dt,df,err,dstd,rstd);
	fflush(stdout);
	} // end df loop
    }  // end dt loop
    ttol=ttol/2;
    tstart=bestfshdt-2*ttol;
    tend=bestfshdt+2.5*ttol;
    ftol=ftol/2;
    fstart=bestfshdf-2*ftol;
    fend=bestfshdf+2.5*ftol;
    if(ttol<0.001){
      ttol=0.0005;
      tstart=bestfshdt;
      tend=tstart+ttol/10;
    }
    if(ftol<10000){
      ftol=5000;
      fstart=bestfshdf;
      fend=fstart+ftol/10;
    }
    printf("%g %g\n",ftol,ttol);
    } // end while
    } // end skipsearch case
    printf("bestfshdt=%g bestfshdf =%g  minerr=%g\n",bestfshdt,bestfshdf,minfsherr);
         
        for(int i=0;i<N;i++){
		try{
		  Time time_eph, time_att;
		  double teph=tperi+t[i]+best_time_err;
		  double tatt=tperi+t[i]+bestfshdt;
		  time_eph.setEt(teph);
		  time_att.setEt(tatt);
		  DirectionVector b3bore_old(bf,tatt,0,0,1);
		  TargetGeom tg(time_eph);
		  tg.setTarget();
		  b3bore_old.representIn(j2000);
		  b3bore_old.setTime(time_eph);
		  b3bore_old.representIn(tf);
		  StateVector sc_state;
		  tf.ephemeris(sc_state,"Cassini",time_eph,"NONE");
		  tg.setState(sc_state);
		  tg.setLookDirection(b3bore_old);
		  Uvar lambda2=speed_light/(carrfreq+Uvar(bestfshdf,"Hz"));
		  duv=tg.doppler(lambda2);
		  ruv=tg.range();
		}
		catch(ErrorMessage e){
		  duv=Uvar(1e6,"Hz");
                  ruv=Uvar(1e3,"km");
		}
		fshiftdop[i]=dop[i]+ddmed[i]-duv.getInUnits("Hz");
		fshiftrange[i]=range[i]+drmed[i]-ruv.getInUnits("Hz");
	}

    // est minimum MSE ephemeris (Kepplerian with altitude error at periapsis and time offset)
    // AND compute residual doppler and range errors
    double best_dt_att=0; 
    double best_dt_eph=0;
    minmse=100000000000.0;

    // This part is no longer in use
    if(0){
    for(float dt=best_time_err-0.1;dt<=best_time_err+0.1;dt+=0.01){
      for(float dt2=-1;dt2<=1;dt2+=0.05){
	int num=0;
	double mse=0;
	for(int i=0;i<N;i++){
	  double r1=0,d1=0;
	  try{
	    Time time_eph, time_att;
	    double teph=tperi+t[i]+dt;
	    double tatt=tperi+t[i]+dt2;
	    time_eph.setEt(teph);
	    time_att.setEt(tatt);
	    DirectionVector b3bore_old(bf,tatt,0,0,1);
	    TargetGeom tg(time_eph);
	    tg.setTarget();
	    b3bore_old.representIn(j2000);
            b3bore_old.setTime(time_eph);
            b3bore_old.representIn(tf);
	    StateVector sc_state;
	    tf.ephemeris(sc_state,"Cassini",time_eph,"NONE");
	    tg.setState(sc_state);
	    tg.setLookDirection(b3bore_old);
	
	    Uvar rangeuv=tg.range();
	    Uvar doppleruv=tg.doppler(lambda);
	    r1=rangeuv.getInUnits("km");
	    d1=doppleruv.getInUnits("Hz");
	  }
	  catch(ErrorMessage e){
	    r1=0;
	    d1=0;
	  }
	  if(r1!=0 && range[i]!=0){
	    num++;
	    float doperr=(d1-(dop[i]+ddmed[i]))/1000;
	    float rangeerr=r1-(range[i]+drmed[i]);
	    mse+=doperr*doperr+rangeerr*rangeerr;
	  }
	}
	mse/=num;
	if(minmse>mse){
	  minmse=mse;
	  best_dt_eph=dt;
	  best_dt_att=dt2;
	}
	printf("dt_eph=%g dt_att=%g RMS=%g\n",dt,dt2,sqrt(mse));
      }
    }

    for(int i=0;i<N;i++){
      double r1=0,d1=0;
      try{
	Time time_eph, time_att;
	double teph=tperi+t[i]+best_dt_eph;
	double tatt=tperi+t[i]+best_dt_att;
	time_eph.setEt(teph);
	time_att.setEt(tatt);
	DirectionVector b3bore_old(bf,tatt,0,0,1);
	TargetGeom tg(time_eph);
	tg.setTarget();
	b3bore_old.representIn(j2000);
	b3bore_old.setTime(time_eph);
	b3bore_old.representIn(tf);
	StateVector sc_state;
	tf.ephemeris(sc_state,"Cassini",time_eph,"NONE");
	tg.setState(sc_state);
	tg.setLookDirection(b3bore_old);
	
	Uvar rangeuv=tg.range();
	Uvar doppleruv=tg.doppler(lambda);
	r1=rangeuv.getInUnits("km");
	d1=doppleruv.getInUnits("Hz");
      }
      catch(ErrorMessage e){
	r1=0;
	d1=0;
      }
      if(r1==0 || range[i]==0){
	dr2t[i]=2575;
	dd2t[i]=1000000;
      }
      else{
	dr2t[i]=range[i]+drmed[i]-r1;
	dd2t[i]=dop[i]+ddmed[i]-d1;
      }
    }
    }
    // write output file
    FILE* ofp=fopen(outfile,"w");
    fprintf(ofp,"# Best_freqshift=%g Best_atttime_error=%g Best_ephtime_error=%g\n",bestfshdf,bestfshdt,best_time_err);
    fprintf(ofp,"# Best att time error=%g Best eph time error=%g\n",best_dt_att,best_dt_eph);
    for(int i=0;i<N;i++){
      fprintf(ofp,"%g %d %g %g %g %g %g %g %g %g %g %g %g %g %g\n",t[i],sabc[i],
	      range[i],dop[i],drmed[i],ddmed[i],drbe[i],ddbe[i],ang[i],ht[i],ddht[i],dr2t[i],dd2t[i], fshiftdop[i], fshiftrange[i]);
    }
    fclose(ofp);
  
  }
catch(ErrorMessage& e)
  {
  cerr << "Error: " << e.msg << endl;
  }
catch(...)
  {
  cerr << "Exception caught" << endl;
  }

return(0);

}
