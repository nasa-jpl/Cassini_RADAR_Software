//-------------------------------------------
// L0 - L1B processor
// This program is to decode archieved level_0 radar telemetry file
// into Level_1B file.  Archieve file is generated by ROME software
// in SUN machine located at Building 230. ROME software also puts 
// raw CCSDS packets into Level_0 file.
// Out l0_l1b program will access only science archive portion of
// Level_0 telemetry file and decode all the science field data 
// described in radar blue book.
// 
// usage: l0_l1b config_file_name option[blank, sclk, sab or epoch_relative_time] unit
//      option blank(no option): decoded every science archive record in Level 0 file 
//      option sclk, sab or epoch_relative_time: decode portion of science archieve data
//      specified in config file in terms of  s/c clock (sclk), sab number (sab)
//      or epoch relative (epoch_relative_time)
//-----------------------------------------------

#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <iostream>
#include <vector>
#include <map>
#include "Config.h"
#include "Io.h"
#include "Units.h"
#include "Error.h"
#include "Sab.h"
#include "Config.h"
#include "L1B.h"
#include "config_keywords.h"
#include "Utils.h"
#include "RasList.h"
#include "IebList.h"
#include "Beam.h"
#include "Flyby.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::cerr;

void myUnexpected() throw()
  {
  cout << "Unexpected exception" << endl;
  std::terminate();
  }

int main(int argc, char* argv[])

{

std::set_unexpected(myUnexpected);

try
  {

  //------------------------
  // Parse the command line
  //------------------------

  const char* command = argv[0];
  if (argc != 4 && argc != 3)
    {
    cerr << "Usage: " << command << " config_file segment_option[all or blank_space, sclk, sab, epoch_relative_time] units_mode" << endl;
    cerr<<"segment option: (1) all or blank space: decode all data, "<<endl;
    cerr<<"segment option: (2) sclk: records between l0_sclk_start and l0_sclk_end in config file "<<endl;
    cerr<<"segment option: (3) sab: records between l0_sab_counter_start and l0_sab_counter_end"<<endl;
    cerr<<"segment option: (4) epoch_relative_time: specified epoch_relative time, epoch time will be obtained from flyby object"<<endl;
    exit(-1);
    }
  

  char* config_file =NULL;
  char* segment_option=NULL;
  char* units_mode =NULL;

  //-----------------
  //Parse the input options
  //----------------
  int clidx = 1;
  if(argc==3){
    config_file = argv[clidx++];
    units_mode = argv[clidx++];
  }
  else{
    config_file = argv[clidx++];
    segment_option=argv[clidx++];
    units_mode = argv[clidx++];
  }

  //----------------------------
  // Set unit mode
  //----------------------------
  set_unit_option(units_mode);

  //------------------------------
  // Load configuration parameters
  //------------------------------
  Config cfg(config_file);

  //----------------------
  //data take number
  //-----------------------
  unsigned int dtn=(unsigned int) cfg.getInt("data_take_number");

  //----------------------
  //trigger time adjust
  //------------------------
  int trigger_time_adjust_in_sclk_tick=cfg.getInt("Adjust_TFI_in_units_of_sclk");
  unsigned int show_sclk_text=0;
  if(cfg.keywordExists("Show_sclk_adjust_message")) show_sclk_text=cfg.getInt("Show_sclk_adjust_message");

  //----------------------------
  //make a text file to report preprocessor run
  //----------------------------
  string report_file="l0_l1b.report2.txt";
  ofstream fout(report_file.c_str());

  //----------------------------------------
  //Specifiy filename
  //----------------------------------------
  string l1b_a_filename = cfg.str(L1B_ACTIVE_MODE_FILENAME);
  string l1b_p_filename = cfg.str(L1B_PASSIVE_MODE_FILENAME);

  //--------------------------
  // Before doing any further processing, check whether L1B output files exist
  //---------------------------
  bool auto_overwrite_l1b = false;
  if (cfg.keywordExists("overwrite_existing_l1b_files")){
    auto_overwrite_l1b = (bool) cfg.getInt("overwrite_existing_l1b_files");
  }
  if (!auto_overwrite_l1b){
    if (fileExists(l1b_a_filename) || fileExists(l1b_p_filename)){
      char resp[5];
      cout << "Overwrite existing L1B output files?  ([nN]/yY)  ";
      cerr << "Overwrite existing L1B output files?  ([nN]/yY)  ";
      cin.getline(resp, 5);
      if (resp[0] != 'y' && resp[0] != 'Y'){
	ErrorMessage("L1B output files exist and will not be overwritten.  Exiting.").throwMe();
      }
    }
  }

  //----------------------
  // Load spice kernel files
  //----------------------
  Frame::config(cfg);
 

  //--------------------------------------------------------
  // Construct beam class objects
  //Need beam pattern for {active, passive} measurement geometry calculations
  //---------------------------------------------------------
  Umat azim_1way3dB_ellipse_fit("azimuth ellipse fit",5,4);
  Umat elev_1way3dB_ellipse_fit("azimuth ellipse fit",5,4);
  Umat azim_2way3dB_ellipse_fit("azimuth ellipse fit",5,4);
  Umat elev_2way3dB_ellipse_fit("azimuth ellipse fit",5,4);
  azim_1way3dB_ellipse_fit=Uvar(0,"rad");
  elev_1way3dB_ellipse_fit=Uvar(0,"rad");
  azim_2way3dB_ellipse_fit=Uvar(0,"rad");
  elev_2way3dB_ellipse_fit=Uvar(0,"rad");
  
  for (unsigned int i = 0; i < 5;i++){
    Beam beam(i+1,cfg,true);
    Uvec azi1_fit("azi fit",4), elev1_fit(" ",4);    
    beam.computeBestFitEllipse(azi1_fit,elev1_fit,-3.0);//one way 3dB  
    for(unsigned int j=0;j<4;++j){
      azim_1way3dB_ellipse_fit(i,j)= azi1_fit(j);
      elev_1way3dB_ellipse_fit(i,j)=elev1_fit(j);
    }    
    Uvec azi2_fit("azi fit",4), elev2_fit(" ",4);   
    beam.computeBestFitEllipse(azi2_fit,elev2_fit,-1.5);//two way 3dB   
    for(unsigned int j=0;j<4;++j){
      azim_2way3dB_ellipse_fit(i,j)= azi2_fit(j);
      elev_2way3dB_ellipse_fit(i,j)=elev2_fit(j);
    }
  }
 

  //-------------------------
  //Extract epoch time from flyby
  //-------------------------
  Time epoch_time;
  string target=cfg.str("target");
  if(strcasecmp(target.c_str(),"none")==0 ||
     strcasecmp(target.c_str(),"source")==0){
    cout<<"No planetary target is specified "<<endl;
    cout<<"Epoch time will be read in from config file "<<endl;
    string epoch_string=cfg.str("epoch_time");
    epoch_time=Time(epoch_string);
    cout<<"Config epoch time "<< epoch_time.utc("ISOD")<<" "<<epoch_time.utc("ISOC")<<endl;
  }
  else{
    cout<<"epoch time will be computed by flyby object"<<endl;
    Flyby flyby(cfg);
    epoch_time = flyby.epochTime();
    cout<<"Flyby epoch time "<< epoch_time.utc("ISOD")<<" "<<epoch_time.utc("ISOC")<<endl;
  }


  //----------------------------------------------------------------------
  //Setup Preprocessor Data Segmentaion Option:
  //  no_option, sclk, sab_number, or epoch_relative time
  //--------------------------------------------------------------------
  unsigned int segment_flag;
  unsigned int L0_sab_counter_start, L0_sab_counter_end;
  unsigned int L0_sclk_start, L0_sclk_end;
  if(segment_option==NULL) segment_flag=0;
  else{
    string segment_string = segment_option;
    if(segment_string=="all") segment_flag=0;
    else if(segment_string=="sclk"){
      //------------------------------
      //segmentation with spacecraft clock
      //-----------------------------
      segment_flag =1;
      int sclk_input = cfg.getInt("L0_sclk_start");
      if(sclk_input<0) ErrorMessage("L0_sclk_start is less than 0");
      L0_sclk_start =(unsigned int) sclk_input;
    
      sclk_input= cfg.getInt("L0_sclk_end");
      if(sclk_input<0) ErrorMessage("L0_sclk_end is less than 0");
      if((unsigned int) sclk_input < L0_sclk_start)
	ErrorMessage("starting SCLK is larger than ending SCLK").throwMe();
      L0_sclk_end = (unsigned int) sclk_input;
    }
    else if(segment_string=="sab"){
      //------------------
      //segmentation with sab counter
      //------------------
      segment_flag=2;
      int sab_input;
      sab_input=cfg.getInt("L0_sab_counter_start");
      if(sab_input<1) 
	ErrorMessage("sab counter should be larger than 0").throwMe();
      L0_sab_counter_start = sab_input;
      
      sab_input=cfg.getInt("L0_sab_counter_end");
      if(sab_input<1) 
	ErrorMessage("sab counter should be larger than 0").throwMe();
      if( (unsigned int) sab_input < L0_sab_counter_start)
	ErrorMessage("starting sab counter is larger than ending sab counter").throwMe();
      L0_sab_counter_end = sab_input;
    }
    else if(segment_string=="epoch_relative_time"){
      //-----------------------
      //Segmentation  with epoch relative time: convert into sclk
      //------------------------
      segment_flag=1;//same as SC clock
      Time epoch=epoch_time;
      cout<<"sclk of epoch "<< epoch.sclk("Cassini")<<endl;
      Uvar l0_start=cfg["L0_epoch_relative_time_start"];
      Uvar l0_end = cfg["L0_epoch_relative_time_end"];
      if(l0_end < l0_start)
	ErrorMessage("segmentation end time is earlier than start time").throwMe();
      Time l0_start_time = epoch + l0_start;
      Time l0_end_time = epoch+l0_end;
      L0_sclk_start = l0_start_time.sclk("Cassini");
      L0_sclk_end = l0_end_time.sclk("Cassini");
    }
    else{
      ErrorMessage("Invalid data segmentation option").throwMe();
    }
  }
  
  

  
  //----------------------------------------
  //Set Level1B active and passive files
  //----------------------------------------
  BurstData::config(cfg);
  L1B l1b_p(l1b_p_filename,"wb","passive");
  L1B* l1b_a;
  l1b_p.config(cfg);


  //-------------------------------------------------------------
  //Set RASLIST and IEBLIST
  // intermediate(contain only echo data) file and ieb file
  //-------------------------------------------------------------
  string ras_filename = cfg.str("ras_filename");
  RasList raslist(ras_filename,"wb");


  //----------------------
  //Check div bursts in flight keyword
  // The purpose of this action is to extract
  // num_bursts_in_flight information which
  // is not contained in downlinked radar
  // telemetry file
  //-----------------------
  bool Is_bif_on= false;//default setting
  Config::numbers div_start_time_map;
  Config::numbers div_end_time_map;
  Config::numbers div_bursts_in_flight_map;
  Config::numbers div_prf_map;
 
  cfg.suffixSet("div_start_time_",div_start_time_map);
  cfg.suffixSet("div_end_time_",div_end_time_map);
  cfg.suffixSet("div_n_bursts_in_flight_",div_bursts_in_flight_map);
  cfg.suffixSet("div_prf_",div_prf_map);

 if((div_start_time_map.size() != div_end_time_map.size()) ||
    (div_start_time_map.size() != div_bursts_in_flight_map.size()) ||
    (div_start_time_map.size() != div_prf_map.size()) ){
   cout<<"start time map size "<< div_start_time_map.size()<<endl;
   cout<<"end   time map size "<< div_end_time_map.size()<<endl;
   cout<<"bif    map size      "<< div_bursts_in_flight_map.size()<<endl;
   cout<<"prf    map size      "<< div_prf_map.size();
   ErrorMessage("div parameter size mismatch").throwMe();
 }
  
  Config::numbers::const_iterator pstart=div_start_time_map.begin();
  Config::numbers::const_iterator pend=div_end_time_map.begin();
  Config::numbers::const_iterator pbif=div_bursts_in_flight_map.begin();
  Config::numbers::const_iterator pprf=div_prf_map.begin();
  for(pbif= div_bursts_in_flight_map.begin();
      pbif != div_bursts_in_flight_map.end(); pbif++){
    if( (unsigned int) round_double((pbif->second).getInUnits(""))!=1){
      Is_bif_on= true;
      break;
    }
  }
  if(Is_bif_on) cout<<"Config file contains division(s) that has burst_in_flight number other than 1"<<endl;



  //----------------------------------------
  //Determine the burst ordered ieb filename
  //----------------------------------------
  string ieb_filename=cfg.str("burst_ordered_ieblist");
  IebList ieblist(cfg);

  

  //--------------------------------
  //set Level0 filename
  // and read record counts
  //--------------------------------
  string input_filename = cfg.str(EGSE_FILENAME);
  FileMgr input_file(input_filename,"rb");
  int record_type = Sab::archive_header;
  input_file.readKnown(record_type);

  
  //--------------------------------
  //Declare SAB 
  //---------------------------------
  Sab sab(input_file.machineType());  // handles header, footer, and data.

  
  //----------------------------
  //Read record length and count
  //-----------------------------
  int record_length,record_count;
  input_file.read(record_length);
  input_file.read(record_count);
  cout<< record_length << ", " << record_count << endl;
  
  //-------------------------
  //Skip 80 character space before reading data
  //------------------------
  string first_written(40,' '),last_written(40,' ');
  input_file.read(first_written);
  input_file.read(last_written);

 
  //---------------------------------------------------
  //Read SABs and decode sab sclk and sab counter only
  // in order to fix any bit bit corruptions in the two fields
  //At the same time, count number of incomplet sab
  //----------------------------------------------------
  unsigned int incomplete_sab_count=0;
  unsigned int complete_sab_count=0;
  
  map<unsigned int, unsigned int> full_path_sab_counter;
  map<unsigned int, unsigned int> full_path_sclk;
  map<unsigned int, unsigned int> full_path_fin,full_path_bii, full_path_ctbc;
  map<unsigned int, Uvar>  full_path_brst,full_path_bpd;
  map<unsigned int, unsigned int> full_path_trigger_time;
  map<unsigned int, Uvar> full_path_tfi;

  //-----------------------
  //clear sab: decode header
  //------------------------
  sab.clear();
  for(int i=1;i<record_count;++i){
    if (input_file.eof())   break;
    input_file.read(record_type);
    input_file.read(record_length);
    Sab::cdata record(record_length);
    input_file.read(record);
    if (record_type == Sab::sci){
      //--------------------------
      //collect only science sab
      //--------------------------
      sab.addData(record);
      if (sab.complete()){
	sab.decode();//decode all header and footer
	full_path_sclk[complete_sab_count]=sab.sclk;
	full_path_sab_counter[complete_sab_count]= sab.sab_counter;
	
	//add the following paramters
	// for time corrections
	full_path_fin[complete_sab_count]=sab.fin;
	full_path_bii[complete_sab_count]=sab.bii;
	full_path_ctbc[complete_sab_count]=sab.ctbc;
	full_path_brst[complete_sab_count]=sab.brst;
	full_path_bpd[complete_sab_count]=sab.bpd;
	full_path_tfi[complete_sab_count]=sab.fast_tfi;
	
	//keep full path iebtth iebttl when subr=15
	if(sab.subr==15)
	  full_path_trigger_time[complete_sab_count]= sab.iebtth*65536 + sab.iebttl;
	
	complete_sab_count++;
      }
      else{ 
	incomplete_sab_count++;
	cout<<"incomplte sab "<<endl;
      }
    }//end of science sab data collection
    sab.clear();//whether it is complete or not
  }
    
  //---------------------------------------
  //Check the container size : should match
  //---------------------------------------
  if(full_path_sab_counter.size()!=full_path_sclk.size()) 
    ErrorMessage("sab counter container size does not agree with sclk container size").throwMe();
  if(full_path_sab_counter.size() != complete_sab_count) 
    ErrorMessage("sab counter size is not equal to number of complete sabs").throwMe();

  if(!(complete_sab_count == full_path_fin.size() &&
       complete_sab_count == full_path_bii.size() &&
       complete_sab_count == full_path_ctbc.size() &&
       complete_sab_count == full_path_brst.size() &&
       complete_sab_count == full_path_bpd.size())){
    cout<<"Error: container size mismatch "<<endl;
    cout<<"expected container size "<< complete_sab_count<<endl;
    cout<< full_path_fin.size()<<" "<< full_path_bii.size()<<endl;
    cout<< full_path_ctbc.size()<<" "<<full_path_brst.size()<<" "<< full_path_bpd.size()<<endl;
  }
  
  //------------------------------------------
  //Unwrap sab counter and fix bit corruptions
  //Option "true"  makes two plots
  // sab counter and sclk both as a function of record index
  // fixCassiniSabSclk is in Unilts.cpp
  //------------------------------------------
  unsigned int first_good_record;
  unsigned int num_sab_counter_roll_over;
  bool plot_output=false;
  cout<<"start unwrapping sab counter and correct possible sclk bit corruption"<<endl;
  fixCassiniSabSclk(full_path_sab_counter, full_path_sclk,
		    first_good_record, num_sab_counter_roll_over, plot_output);
 

  //--------------------------
  //fix fin number roll over
  //--------------------------
  fixFinNumberRollOver(full_path_fin, 256);//8 bit 

  //------------------------------------------------------
  // After correcting sab counter and sclk bit corruption,
  // recompute sclk and brst w.r.t. first record of each new
  // instruction
  //------------------------------------------------------
  unsigned int sclk_correction=0;
  unsigned int brst_correction=0;
  unsigned int bpd_correction=0;
  unsigned int bii_correction=0;
  unsigned int tfi_correction=0;
  //computeSCLKandBRST(full_path_sab_counter,
  //	     full_path_sclk,
  //	     full_path_fin,
  //	     full_path_bii,
  //	     full_path_ctbc,
  //	     full_path_brst,
  //	     full_path_bpd,
  //	     sclk_correction,
  //	     brst_correction,
  //	     bpd_correction,
  //	     bii_correction);
  
 
  cout<<"IEB trigger time adjust "<< trigger_time_adjust_in_sclk_tick<<endl;
  computeBurstTimeUsingTFI(full_path_sab_counter,
			   full_path_sclk,
			   full_path_fin,
			   full_path_bii,
			   full_path_ctbc,
			   full_path_brst,
			   full_path_bpd,
			   full_path_tfi,
			   full_path_trigger_time,
			   sclk_correction,
			   brst_correction,
			   bpd_correction,
			   bii_correction,
			   tfi_correction,
			   trigger_time_adjust_in_sclk_tick,
			   show_sclk_text);



  cout<<"sclk brst bpd bii correction "<< sclk_correction<<" "<< brst_correction<<" "<< bpd_correction<<" "<<bii_correction<<endl;
  cout<<"bii and tfi correction "<< bii_correction<<" "<<tfi_correction<<endl;
  //------------------------------------------------------
  //  apply data sementation option
  // sab_selected: true or false
  //-------------------------------------------------------
  cout<<"Applying data segmentation option "<<endl;
  map<unsigned int, bool> sab_selected;
  sab_selected.clear();
  for(unsigned int i=0;i<complete_sab_count;++i){
    if(i < first_good_record) {
      sab_selected[i]=false;
      continue;
    }
    else{
      if(segment_flag==0) sab_selected[i]=true;
      else{
	bool is_sab_selected= false;
	switch(segment_flag){
	case 1://based on l0_sclk
	  if( full_path_sclk[i]>=L0_sclk_start &&
	      full_path_sclk[i]<=L0_sclk_end) 
	    is_sab_selected=true;
	  break;
	case 2://based on sab counter
	  if( full_path_sab_counter[i]>=L0_sab_counter_start &&
	      full_path_sab_counter[i]<=L0_sab_counter_end)
	    is_sab_selected= true;
	  break;
	default:
	  break;
	}
	sab_selected[i]=is_sab_selected;
      }
    }
  }
  
 
  
  
  //---------------------------------
  // Setup L1B Header
  //---------------------------------
  l1b_p.writeHeader();

  
  //----------------------
  //declare variables
  //------------------------ 
  unsigned int isab = 0;
  unsigned int count_incomplete_sab = 0;
  unsigned int num_invalid_sab=0;
  unsigned int num_missing_sabs=0;
  unsigned int num_time_swapped=0;
  unsigned int num_radar_tick_error=0;
  unsigned int num_larger_1s_error=0;
  unsigned int num_smaller_1s_error=0;
  int num_records_p=0;
  int num_records_a=0;
  unsigned int num_bursts_in_flight=1;
  Uvar epoch_relative_time;
  string div_name;
  Uvar div_prf;
  Uvar prf;
  unsigned int first_good_sab_counter;
 
  //--------------------------------
  //List of parameters recycled inside for loop
  //----------------------------------
  Ieb ieb;
  bool valid_ieb= true;
  Time t_sab;
  unsigned int ieb_mode=0;
  Time t;

  //---------------------------------------
  //List of parameters to be kept from previous Sab record
  //---------------------------------------
  Time t_hold ;
  Uvar burst_period_hold;
  unsigned int fin_hold;
  unsigned int slow_instruction_number_hold;
  unsigned int sclk_hold;
  unsigned int sab_counter_hold;
  Uvar brst_hold;

  //----------------------------
  //Computed parameters by comparing two nearby Sabs
  //----------------------------
  Uvar sab_time_diff;
  unsigned int sab_counter_diff;
  unsigned int current_sab_counter;

  //-------------------
  //contain error code
  //-------------------
  map<unsigned int, int> error_code;

  //-----------
  //speical var to handle mulitple bursts
  //----------  
  Uvar prf_modified;//special variable to handle multiple bursts
  unsigned int pri_number;//speical variable to handle mulitple bursts
  unsigned int sab_pri_number;
  Uvar pri_modified;
  //---------------------------------
  //Let's rewind and read header again
  //---------------------------------
  input_file.rewind();
  record_type= Sab::archive_header;
  input_file.readKnown(record_type);
  input_file.read(record_length);
  input_file.read(record_count);
  input_file.read(first_written);
  input_file.read(last_written);


  //-----------------------------------
  //Let's process one by one
  //-----------------------------------
  sab.clear();//clear any existing sab
  bool  foundFirstGoodRecord=false;
  isab=0;
  for (int i=1; i <= record_count; ++i){
    if (input_file.eof()){
      cerr << "Premature end of file while reading from "
	   << input_file.name() << endl
	   << record_count - i + 1 << " packet(s) missing" << endl;
      break;
    }
    input_file.read(record_type);
    input_file.read(record_length);
     
    Sab::cdata record(record_length);
    input_file.read(record);
    if (record_type == Sab::sci){//read only science sab
      sab.addData(record);//should be either complete or not
      if (sab.complete()){
	if(isab>=complete_sab_count) {
	  cerr<<"Previously computed complete sab: "<<complete_sab_count<<endl;
	  cerr<<"Number of complete sab  counter:"<<isab<<endl;
	  break;
	}
	
	//-----------------------------------
	//Print percentage of complete SABs
	//------------------------------------
	if(isab%1000==0) 
	  cout<<round_double(double(isab)/double(complete_sab_count)*100.0)
	      <<"% complete "<<endl;


	//------------------------------
	//decode SAB header, footer, and data
	//-------------------------------
	sab.decode();  
	if(dtn != sab.dtn) sab.dtn=dtn;

	sab.baq_decode();

	//---------------------------------------------------------
	//add into ras file whether the current sab is valid or not
	//---------------------------------------------------------
	if(sab.Ndecoded)
	  raslist.loadSab(sab);//active mode written  into ras file
       
	//-----------------------------
	//Apply data segmentation option
       	//----------------------------
	if(!sab_selected[isab]){
	  //not selected, skip this record
	  isab++;//increase number of sab decoded by 1
	  sab.clear();
	  continue;
	}
	
	
	//--------------------------
	//Check decoded SAB  is valid
	//----------------------------
	if(!sab.Valid()){
	  error_code[sab.sab_counter]=sab.getErrorInfo();
	  num_invalid_sab++;
	  cout<<"invalid sab "<<num_invalid_sab<<endl;
	  cout<<endl;
	  //--------------------------------------------
	  //It was decided that we should include even 
	  //bad SAB into LBDR/SBDR
	  //If we ever decided to change those decision,
	  // just activate the following two lines
	  //-------------------------------------------
	  //isab++
	  //sab.clear();
	  //continue;//skip this isab record
	}



	//---------------------------------
	//Assign fixed  sclk, brst,
	//             sab_counter,
	//              fin, bpd
	//--------------------------------
	if(sab.sclk!=full_path_sclk[isab]){
	  //cout<<"sclk correction is applied "<<endl;
	  //cout<<"complete sab index number "<<isab<<endl;
	  //cout<<"original sab sclk "<<sab.sclk<<endl;
	  //cout<<"corrected sab sclk "<< full_path_sclk[isab]<<endl;
	  //cout<<"Corrected sab sclk will be used" <<endl;
	  sab.sclk=full_path_sclk[isab];
	}
	if(sab.brst!=full_path_brst[isab]){
	  //cout<<"brst correction "<<endl;
	  //cout<<"orginal "<< sab.brst<<endl;
	  //cout<<"new  "<< full_path_brst[isab]<<endl;
	  sab.brst=full_path_brst[isab];
	}
	if(sab.sab_counter!=full_path_sab_counter[isab]){
	  //cout<<"sab counter correction is applied "<<endl;
	  //cout<<"complete sab index number "<<isab<<endl;
	  //cout<<"original sab counter "<< sab.sab_counter<<endl;
	  //cout<<"corrected sab counter "<< full_path_sab_counter[isab]<<endl;
	  //cout<<"Corrected sab counter will be used "<<endl;
	  sab.sab_counter=full_path_sab_counter[isab];
	}
	current_sab_counter = sab.sab_counter; 
	
	if(sab.fin!=full_path_fin[isab]){
	  //cout<<"fin number correction "<<endl;
	  //cout<<"original fin "<< sab.fin<<endl;
	  //cout<<"new fin "<< full_path_fin[isab]<<endl;
	  sab.fin=full_path_fin[isab];
	}
	
	if(sab.bpd!=full_path_bpd[isab]){
	  //cout<<"bpd correction "<<endl;
	  //cout<<"old bpd "<<sab.bpd<<endl;
	  //cout<<"new bpd "<<full_path_bpd[isab]<<endl;
	  sab.bpd=full_path_bpd[isab];
	}
	
	
	//--------------------------------------
	//keep the current sab and 
	//find good record value if sab is valid
	//--------------------------------
	if(sab.Valid() && !foundFirstGoodRecord){
	  foundFirstGoodRecord=true;
	  first_good_sab_counter=current_sab_counter;
	  //-------------------------------------------
	  //Special treament for first SAB that is valid
	  //-------------------------------------------
	  t.setSclk("Cassini",sab.sclk);
	  t += sab.brst;
	  cout<<"First good  record's utc time "<<t.utc("ISOD")<<endl;
	  l1b_p.recordStartTime(t);
	}
	
	//------------------------------
	//When Sab is valid and not the  first good  record
	//check three things
	//1.  compute missing SABs
	//2.  compute time difference
	//3.  correct sclk error if any
	//---------------------------------
	if(sab.Valid() && 
	   (current_sab_counter>first_good_sab_counter)){
	  
	  sab_counter_diff =current_sab_counter-sab_counter_hold;
	  //---------------------------------
	  //(1) Count number of  missing Sabs
	  //if sab_counter_diff >1, missing sabs
	  //------------------------------------
	  if(sab_counter_diff!=1) {
	    num_missing_sabs +=sab_counter_diff-1;
	    cout<<"missing sabs between "<<sab_counter_hold<<" "
		<<sab.sab_counter<<endl;
	    cout<<"missing sabs "<< sab_counter_diff-1<<endl;
	  }
	  
	  //------------------------------------------------------
	  //(2) Compute time difference between two nearby SABs
	  // Time should increas with sab counter!!!!!
	  // This should not happen
	  //-------------------------------------------------------
	  t.setSclk("Cassini",sab.sclk);
	  t += sab.brst;
	  sab_time_diff = t - t_hold; 
	  if(t<=t_hold){
	    error_code[current_sab_counter]=21;//error code
	    //cout<<"------- should not happen--------------"<<endl;
	    //cout<<" need user interruption "<<endl;
	    //cout<<"current sab counter "<< sab.sab_counter<<endl;
	    //cout<<"Time of current SAB is earlier than previous one "<<endl;
	    //cout<<"This should  not happen "<<endl;
	    //cout<<"sab time difference "<< sab_time_diff<<endl;
	    //cout<<"current record sclk "<< sab.sclk<<endl;
	    //cout<<"current record brst "<< sab.brst<<endl;
	    //cout<<"previous record sclk "<<sclk_hold <<endl;
	    //cout<<"previous record brst "<<brst_hold<<endl;
	    //cout<<"previous sab counter "<< sab_counter_hold<<endl;
	    //cout<<"this is possibly caused by time error of the previous sab "<<endl;
	    //cout<<"previous sclk and brst "<< sclk_hold<<" "
	    //<<brst_hold.getInUnits("ms")<<" ms"<<endl;
	    //cout<<"current sclk and brst "<<sab.sclk<<" "
	    //<<sab.brst.getInUnits("ms")<<" ms"<<endl;
	    //int sclk_diff=(int) sab.sclk - (int) sclk_hold;
	    //double brst_diff= (sab.brst-brst_hold).getInUnits("ms");
	    //cout<<"sclk difference "<<sclk_diff <<endl;
	    //cout<<"brst difference "<<brst_diff<<" ms"<<endl;
	    //cout<<"-----------------------------------"<<endl;
	  }	  
	    
	  //----------------------------
	  //When this is not the first record,
	  //(3) SCLK time error check "Only" when both SABs 
	  // have the same SLOW/FAST instruction
	  // numbers 
	  //:
	  //-----------------------------
	  if(sab.fin == fin_hold &&
	     sab.slow_instruction_number==slow_instruction_number_hold){
	    Uvar expected_sab_time_diff=burst_period_hold*sab_counter_diff; 

	    //------------------------------------------------------------
	    //case(0)normal case: time_diff == expected_sab_time +-0.25 ms
	    //  normal case
	    //-----------------------------------------------------------
	    if((sab_time_diff < (expected_sab_time_diff+Uvar(0.25*mstos,"s")))&&
	       (sab_time_diff > (expected_sab_time_diff-Uvar(0.25*mstos,"s")))){ }//do nothing

	    //-------------------------------------------------------------------
	    //case(1)abnoraml, no action, time_diff < expected_time_diff - 0.25 ms
	    //  radar tick error
	    //-----------------------------------------------------------------------
	    else if (sab_time_diff <= (expected_sab_time_diff -Uvar(0.25*mstos,"s"))){
	      num_radar_tick_error++;
	      //cout<<"----- should not happen -------------------------------"<<endl;
	      //cout<<"Need user interruption "<<endl;
	      //cout<<"sab counter "<<sab.sab_counter<<endl;
	      //cout<<"sab counter hold "<< sab_counter_hold<<endl;
	      //cout<< "sab interval: "<<sab_time_diff.getInUnits("ms")
	      //<<" ms"<<endl;
	      //cout<< "expected sab interval: "<<burst_period_hold.getInUnits("ms")*(double)sab_counter_diff <<" ms"<<endl;
	      //cout<<"burst period : "<<burst_period_hold<<endl;
	      //cout<<" Minor Time error"<<endl;
	      //cout<<"previous sclk and brst "<< sclk_hold<<" "
	      //  <<brst_hold.getInUnits("ms")<<" ms"<<endl;
	      //cout<<"current sclk and brst "<<sab.sclk<<" "
	      //  <<sab.brst.getInUnits("ms")<<" ms"<<endl;
	      //int sclk_diff=(int) sab.sclk - (int) sclk_hold;
	      //double brst_diff= (sab.brst-brst_hold).getInUnits("ms");
	    }
	    //-----------------------------------------------------------------
	    //case(2) 1s error: time_diff = expected_sab_time + 1s +-0.25 ms
	    // One second sclk error
	    //-------------------------------------------------------------------
	    else if ((sab_time_diff > (expected_sab_time_diff+Uvar(0.25*mstos,"s"))) &&
		     (sab_time_diff < (expected_sab_time_diff+Uvar(1,"s")+Uvar(0.25*mstos,"s"))) &&
		     (sab_time_diff > (expected_sab_time_diff+Uvar(1,"s")-Uvar(0.25*mstos,"s")))){
	      num_time_swapped++;
	      //cout<<"----- should not happen -------------------------------"<<endl;
	      //cout<<"Need user interruption "<<endl;
	      //----------------------
	      //Two nearby SABs have a time difference
	      // larger than their expected burst period
	      // by 1 s
	      //-----------------------
	      //cout<<"sab counter "<<sab.sab_counter<<endl;
	      //cout<<"sab counter hold "<< sab_counter_hold<<endl;
	      //cout<< "sab interval: "<<sab_time_diff.getInUnits("s")
	      //  <<" s"<<endl;
	      //cout<< "expected sab interval: "<<endl;
	      //cout<<burst_period_hold.getInUnits("s")*(double)sab_counter_diff
	      //  <<" s"<<endl;
	      //cout<<"burst period : "<<burst_period_hold<<endl;
	      //cout<<" Time error"<<endl;
	      //cout<<"Time difference is 1 sec + bpd "<<endl;
	      //cout<<"Therefore, SCLK will be reduced by 1 s "<<endl;
	      //cout<<endl;
	      //sab.subtract1secfromSCLK(); 
	      //cout<<"sclk fix "<< num_time_swapped<<endl;
	    }
	    //--------------------------------------------------------------
	    //case(3) time_diff ls larger than expected, but less by 1 s+bpd
	    //larger than radar tick but smaller than 1s
	    //---------------------------------------------------------------
	    else if((sab_time_diff >= (expected_sab_time_diff + Uvar(0.25*mstos,"s"))) &&
		    (sab_time_diff <= (expected_sab_time_diff + Uvar(1,"s")-Uvar(0.25*mstos,"s")))){
	      num_smaller_1s_error++;
	    }
	    //----------------------------------------------------------
	    //case(4) time_diff larger than expected by more than 1 s
	    // larger than 1 s error
	    //-----------------------------------------------------------
	    else if( (sab_time_diff > (expected_sab_time_diff+Uvar(0.25*mstos,"s")))&&
		     (sab_time_diff >= (expected_sab_time_diff+Uvar(1,"s")+Uvar(0.25*mstos,"s")))){
	      num_larger_1s_error++;
	      //-------------
	      //two nearby SAB time diff larger than expected
	      // the diff is larger than 1 s
	      // 
	      //---------------
	      //cout<<"----- should not happen -------------------------------"<<endl;
	      //cout<<"Need user interruption "<<endl;
	      //cout<<"--------------------------------------"<<endl;
	      //cout<<"Time difference is larger than expected "<<endl;
	      //cout<<"but not 1sec error "<<endl;
	      //cout<<" time difference is larger than expected, and the error is larger than 1 s"<<endl;
	      //cout<<"burst period "<< burst_period_hold<<endl;
	      //cout<<"previous sclk and brst "<< sclk_hold<<" "
	      //  <<brst_hold.getInUnits("ms")<<" ms"<<endl;
	      //cout<<"current sclk and brst "<<sab.sclk<<" "
	      //  <<sab.brst.getInUnits("ms")<<" ms"<<endl;
	      //int sclk_diff=(int) sab.sclk - (int) sclk_hold;
	      //
	      //double brst_diff= (sab.brst-brst_hold).getInUnits("ms");
	      //cout<<"sclk difference "<<sclk_diff <<endl;
	      //cout<<"brst difference "<<brst_diff<<" ms"<<endl;
	      //cout<<"real bdp ms w/o using time class "<<  (double) ( sclk_diff*1000) + brst_diff<<endl; 
	      //cout<<"commanded bdp in ms"<< burst_period_hold.getInUnits("ms")<<endl; 
	      //cout<<"May need more sophisticated algorithm to fix"<<endl;
	      //cout<<"--------------------------------------"<<endl;
	      //cout<<endl;
	    }
	    
	    else{
	      cout<<"--------------------------------------- "<<endl;
	      cout<<"this shoild not happend "<<endl;
	      ErrorMessage("sab time difference error handling ").throwMe();
	    }
	  }
	}//valid SAB ,but not the first good one
	 	  
	//-----------------------------------------------------
	//compute Sab time
	//-----------------------------------------------------
	t_sab.setSclk("Cassini",sab.sclk);
	t_sab+= sab.brst;
	  
	//--------------------------------------------------
	//compute num_bursts_in_flight 
	//in scatterometer only except calibration
	//-------------------------------------------------
	if(!Is_bif_on)
	  num_bursts_in_flight=1;//default setting
	else{
	  epoch_relative_time = t_sab - epoch_time;
	  prf =1/sab.pri;
	  
	  if((sab.r_mode==0 || sab.r_mode==8) &&
	     (sab.csr==0 || sab.csr==8)){
	    pstart=div_start_time_map.begin();
	    pend=div_end_time_map.begin();
	    pbif=div_bursts_in_flight_map.begin();
	    pprf = div_prf_map.begin();
	    for(pstart=div_start_time_map.begin();
		pstart != div_start_time_map.end() &&
		  pend != div_end_time_map.end() &&
		  pbif != div_bursts_in_flight_map.end() &&
		  pprf != div_prf_map.end();
		pstart++,pend++,pbif++,pprf++){
	      //-------------------------------
	      //check whether pri in config file
	      // has multiple units of adc
	      //-----------------------------
	      //config prf convereted into pri number
	      prf_modified = pprf ->second;
	      pri_number=(unsigned int)
		round_double((sab.adc/prf_modified).getInUnits(""));
	      pri_number /=2;
	      pri_number *=2;//make it even

	      //prf modified and pri modified : not being used
	      prf_modified = sab.adc/double(pri_number);
	      pri_modified = double(pri_number)/sab.adc;

	      //convert pri in sab into interger number in units of 1/adc
	      sab_pri_number=(unsigned int)  round_double((sab.pri * sab.adc).getInUnits(""));

	      if( (epoch_relative_time >=(pstart->second - Uvar(60,"s"))) &&
		  (epoch_relative_time < (pend->second   + Uvar(60,"s"))) &&
		  (pri_number == sab_pri_number))
		num_bursts_in_flight = (unsigned int)
		  round_double( (pbif->second).getInUnits(""));
	    }//loop over all divisions
	  }//check bif only when scatt mode
	}//if bif is on
	  
	  
	//-----------------
	//Construct ieb only when sab is valid
	// and then compute ieb mode
	//before save into ieblist
	//-----------------
	if(sab.Valid()){
	  ieb=sab.getIeb();   
	  ieb.setTime(t_sab);
	  
	  //-----------------------
	  //compute Iebmode
	  // iebmode
	  // 4: every mode avail(if all the TFI > 0)
	  // 3: slow/fast field valid
	  // 2: only fast field
	  // 1: only tnc field
	  // 0: only power mode valid
	  //-------------------------
	  ieb.setIebMod(ieb_mode); //set ieb mode 
	  if(ieb_mode!=4){
	    //-----------------------------------------------------
	    //if all of power - tnc - fast - slow are loaded once
	    //do not do this part
	    //-----------------------------------------------------
	    if(ieb.getPowerTfi()==Uvar(0,"s")) 
	      ErrorMessage("No power mode is set before collecting SAB").throwMe();//should not occur
	    if(ieb.getTncTfi()>Uvar(0,"s")) ieb_mode=1;
	    if(ieb.getFastTfi()>Uvar(0,"s")) ieb_mode=2;
	    if(ieb.getSlowTfi()>Uvar(0,"s")) ieb_mode=4;//4
	    ieb.setIebMod(ieb_mode);//reset mode
	    cout<<"fast field tfi "<<ieb.getFastTfi()<<endl;
	    cout<<"slow tfi "<<ieb.getSlowTfi()<<endl;
	    cout<<"power "<<ieb.getPowerTfi()<<endl;
	    cout<<"tnc  "<<ieb.getTncTfi()<<endl;
	    cout<<"ieb mode adjusted to  "<<ieb_mode<<endl;
	  }
	  
	  ieblist.back_insert(ieb, valid_ieb);
	  if(!valid_ieb){
	    cout<<"current sab counter "<<sab.sab_counter<<endl;
	    ieb.decodeSlowFastfield();
	    cout<<"current record tfi "<< ieb.getFastTfi()<<endl;
	    cout<<" fin "<<ieb.getFin()<<endl;
	    cout<<"Current ieb is not the latest one  ";
	    cout<<"even after time correction "<<endl;
	    cout<<"Therefore, current ieb will not stored in  ";
	    cout<<" IebList  "<<endl;
	    error_code[current_sab_counter]=52;//ieb time order error
	    cout<<"last record stored in the ieblist "<<endl;
	    Ieb ieb_tmp;
	    unsigned int num_list=ieblist.getNumberofIebRecords();
	    ieb_tmp=ieblist[num_list-1];
	    ieb_tmp.decodeSlowFastfield();
	    Time tmp_t=ieb_tmp.getTime();
	    unsigned int tmp_sclk;
	    tmp_sclk=tmp_t.sclk("Cassini");
	    cout<<"last record tfi "<< ieb_tmp.getFastTfi()<<endl;
	    cout<<"fin "<< ieb_tmp.getFin()<<endl;
	  }
	}//only when sab is valid
	  
	//------------
	//first, write L1BP
	//---------------
	l1b_p.loadSab(sab);
	if(num_bursts_in_flight>1) l1b_p.setNum_bursts_in_flight(num_bursts_in_flight);
	l1b_p.locate(azim_1way3dB_ellipse_fit,
		     elev_1way3dB_ellipse_fit,
		     azim_2way3dB_ellipse_fit,
		     elev_2way3dB_ellipse_fit);	      
	num_records_p++;
	l1b_p.writeRecord(sab.sab_counter);
	l1b_p.recordStopTime(l1b_p.t);
	l1b_p.recordRadarMode(sab.csr, sab.adc);
	
	//--------------
	//second, write  L1BA: whenever there is non-zero active echo
	//--------------
	if(sab.Ndecoded){
	  if(!num_records_a){
	    l1b_a= new L1B(l1b_a_filename,"wb","active");
	    l1b_a->config(cfg);
	    l1b_a->writeHeader();
	  }
	  num_records_a++;
	  l1b_a->loadSab(sab);
	  if(num_bursts_in_flight>1) l1b_a->setNum_bursts_in_flight(num_bursts_in_flight);
	  l1b_a->locate(azim_1way3dB_ellipse_fit,
			elev_1way3dB_ellipse_fit,
			azim_2way3dB_ellipse_fit,
			elev_2way3dB_ellipse_fit);
	  l1b_a->writeRecord(sab.sab_counter);
	  if (num_records_a == 1){
	    l1b_a->recordStartTime(l1b_a->t);
	  }
	  l1b_a->recordStopTime(l1b_a->t);
	  l1b_a->recordRadarMode(sab.csr, sab.adc);
	}
	
	//-----------------
	//Keep current SAB's parameters only when SAB is valid
	// compare them with the next SAB's ones
	//----------------
	if(sab.Valid()){
	  t_hold = t_sab;
	  sclk_hold = sab.sclk;
	  brst_hold=sab.brst;
	  burst_period_hold = sab.bpd;
	  fin_hold = sab.fin;
	  slow_instruction_number_hold = sab.slow_instruction_number;
	  sab_counter_hold = sab.sab_counter;
	  sab_counter_hold = current_sab_counter;
	}//when SAB is valid
	
     	//----------------------------------------------
	//Clear ieb and increase counter by 1
	//---------------------------------------------
	ieb.clear();//clear for reuse
	isab++;//increase number of sab decoded by 1
      }//end of when sab is complete 
      else{
	count_incomplete_sab++;
	cout << " Incomplete Sab " << count_incomplete_sab << endl;
      }
      sab.clear();//clear sab
    }//science SAB only
  }//loop over record
  
  if(isab !=complete_sab_count) 
    ErrorMessage("Expect  "+toStr(complete_sab_count)+" complete sabs, but only get "+toStr(isab)).throwMe();

  //-------------------
  // L1BP Update headers
  //---------------------
  l1b_p.rewriteHeader();
  if(num_records_a){
    l1b_a->rewriteHeader();
    delete l1b_a;
  }
  //--------------------------
  //write all ieb records  into ieb_file
  //----------------------------
  ieblist.writeAllIebRecords(ieb_filename,"wb");  
  



  //-----------------------------
  //Sab report
  //------------------------------
  cout<<"------------------------------------"<<endl;
  cout<<"Sab report "<<endl;
  cout<<"------------------------------------"<<endl;

  cout<<"Number of SABs "<< num_records_p <<endl;
  cout<<"Number of active records with non-zero echo size " << num_records_a <<endl; 
 
  cout<<"Missing Sabs "<<endl;
  cout<<"Found that "<<num_missing_sabs
      <<" missing sabs"<<endl;
  cout<<endl;

  cout<<"Sab Time Errors "<<endl;
  cout<<"Found that "<<num_time_swapped
      <<" Sab SCLK recording errors"<<endl;
  cout<<endl;

  cout<<"number of radar tick error "<<endl;
  cout<< num_radar_tick_error<<endl;
  cout<<endl;
  

  cout<<"Time error larger than 1 s "<<endl;
  cout<<num_larger_1s_error<<endl;
  cout<<endl;



  cout<<"Time error smaller than 1s "<<endl;
  cout<<num_smaller_1s_error<<endl;
  cout<<endl;


  cout<<"Sab counter roll over "<<endl;
  cout<<"Number of sab counter roll over: "<< num_sab_counter_roll_over<<endl;
  cout<<endl;

 
  
  cout<<"Invalid Sabs"<<endl;
  cout<<"Found "<<num_invalid_sab
      <<" invalid Sab's"<<endl;
  cout<<endl;
  
  cout<<"Incomplete Sabs"<<endl;
  cout << "Found " << count_incomplete_sab
       << " incomplete Sab's" << endl;
  cout<<endl;
  
  if(error_code.size()!=0){
    for(map<unsigned int, int>::const_iterator p=error_code.begin();
	p != error_code.end();++p){
      cout<<"sab number "<< p->first<<"  error code "<< p->second;
      cout<<endl;
    }
  }

  //-------------------
  //write report  into file
  //------------------
  fout<<"------------------------------------"<<endl;
  fout<<"Sab report "<<endl;
  fout<<"------------------------------------"<<endl;

  fout<<"Number of SABs "<< num_records_p <<endl;
  fout<<"Number of active records with non-zero echo size " << num_records_a <<endl; 
 
  fout<<"Missing Sabs "<<endl;
  fout<<"Found that "<<num_missing_sabs
      <<" missing sabs"<<endl;
  fout<<endl;

  fout<<"Time error correction before decoding data "<<endl;
  fout<<"sclk brst correction "<< sclk_correction<<" "<<brst_correction<<endl;
  fout<<"bii correction "<< bii_correction<<endl;
  fout<<"bpd correction "<< bpd_correction<<endl;
  fout<<"tfi correction "<<tfi_correction<<endl;

  fout<<"-------------------------------------------"<<endl;


  fout<<"------------------------------------"<<endl;
  fout<<"corrections that are not supposed to happen "<<endl;

  fout<<"Sab Time Errors "<<endl;
  fout<<"Found that "<<num_time_swapped
      <<" Sab SCLK recording errors"<<endl;
  fout<<endl;

  fout<<"number of radar tick error "<<endl;
  fout<< num_radar_tick_error<<endl;
  fout<<endl;
  

  fout<<"Time error larger than 1 s "<<endl;
  fout<<num_larger_1s_error<<endl;
  fout<<endl;



  fout<<"Time error smaller than 1s "<<endl;
  fout<<num_smaller_1s_error<<endl;
  fout<<endl;
  fout<<"---------- End of erro list -------------------------"<<endl;

  
  fout<<"Sab counter roll over "<<endl;
  fout<<"Number of sab counter roll over: "<< num_sab_counter_roll_over<<endl;
  fout<<endl;

 
  
  fout<<"Invalid Sabs"<<endl;
  fout<<"Found "<<num_invalid_sab
      <<" invalid Sab's"<<endl;
  fout<<endl;
  
  fout<<"Incomplete Sabs"<<endl;
  fout << "Found " << count_incomplete_sab
       << " incomplete Sab's" << endl;
  fout<<endl;
  
  if(error_code.size()!=0){
    for(map<unsigned int, int>::const_iterator p=error_code.begin();
	p != error_code.end();++p){
      fout<<"sab number "<< p->first<<"  error code "<< p->second;
      fout<<endl;
    }
  }

 
  }//end of try

catch(ErrorMessage& e)
  {
    cerr << "Error: " << e.msg << endl;
  }
catch(...)
  {
  cerr << "Exception caught" << endl;
  }

return(0);

}




